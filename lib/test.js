// Generated by LiveScript 1.5.0
var sexpr, partser, parse, parser, parseWithModifications, test, convertToplevel, convert, deleteLocationData, to, testWithModifications, charEscape, toString$ = {}.toString;
sexpr = require('./index.js');
partser = require('partser');
parse = (parser = sexpr(), function(it){
  var s;
  s = parser(it);
  if (s.status) {
    return s.value;
  } else {
    throw Error("Parse error: expected " + s.expected.join(' | ') + " at " + s.index);
  }
});
parseWithModifications = curry$(function(transformer, input){
  var parser, s;
  parser = sexpr();
  transformer.call(null, parser);
  s = parser(input);
  if (s.status) {
    return s.value;
  } else {
    throw Error("Parse error at offset " + s.index + ": expected " + s.expected);
  }
});
test = function(name, func){
  return require('tape')(name, function(t){
    func.call(t);
    return t.end();
  });
};
convertToplevel = function(it){
  switch (toString$.call(it).slice(8, -1)) {
  case 'Array':
    return it.map(convert);
  default:
    return convert(it);
  }
};
convert = function(it){
  var that;
  switch (that = toString$.call(it).slice(8, -1)) {
  case 'Null':
    return null;
  case 'Array':
    return {
      type: 'list',
      content: it.map(convert)
    };
  case 'String':
    if (it instanceof Object) {
      return {
        type: 'string',
        content: it.toString()
      };
    } else {
      return {
        type: 'atom',
        content: it
      };
    }
    break;
  default:
    throw Error("Test error; invalid convenience template (got " + that + ")");
  }
};
deleteLocationData = function(it){
  if (it === null) {
    return it;
  }
  delete it.location;
  if (it.type === 'list') {
    it.content.forEach(deleteLocationData);
  } else if (toString$.call(it).slice(8, -1) === 'Array') {
    it.forEach(deleteLocationData);
  }
  return it;
};
to = curry$(function(input, output, description){
  output = convertToplevel(output);
  return test(description, function(){
    return this.deepEquals(deleteLocationData(
    parse(
    input)), output);
  });
});
testWithModifications = function(description, input, output, transformer){
  output = convertToplevel(output);
  return test(description, function(){
    return this.deepEquals(deleteLocationData(
    parseWithModifications(transformer)(
    input)), output);
  });
};
to('', [])("empty input");
to(' \t', [])("empty input (just whitespace)");
to('a', ['a'])("atom");
to('"a"', [new String('a')])("string");
to('()', [[]])("empty list");
to(' a ', ['a'])("whitespace is insignificant");
to('((a b c)(()()))', [[['a', 'b', 'c'], [[], []]]])("nested lists");
to('((a b c) (() ()))', [[['a', 'b', 'c'], [[], []]]])("nested lists with spacing");
to('(a\nb)', [['a', 'b']])("newlines are not part of atoms");
to('(a b)(a b)', [['a', 'b'], ['a', 'b']])("multiple forms");
to('()( )(\n)', [[], [], []])("multiple empty forms");
to('#!/bin/sh', [])("lone shebang line ignored");
to('#!', [])("lone empty shebang line ignored");
to('\n#!sh', ["#!sh"])("shebang line not at beginning is atom");
to('#!/bin/sh\n(a)', [['a']])("shebang line followed by form");
[['\'', 'quote'], ['`', 'quasiquote'], [',', 'unquote'], [',@', 'unquote-splicing']].forEach(function(arg$){
  var c, name;
  c = arg$[0], name = arg$[1];
  to(c + "a", [[name, 'a']])(name + "'d atom");
  to(c + "\"a\"", [[name, new String('a')]])(name + "'d string");
  to(c + "()", [[name, []]])(name + "'d empty list");
  to(c + "(a b c)", [[name, ['a', 'b', 'c']]])(name + "'d list with contents");
  to("(" + c + "a)", [[[name, 'a']]])(name + "'d atom in a list");
  to("(a " + c + " b)", [['a', [name, 'b']]])("whitespaced " + name);
  to("(a " + c + c + " b)", [['a', [name, [name, 'b']]]])("consecutive " + name + "s nest");
  to("(a" + c + "b)", [['a', [name, 'b']]])(name + " acts as delimiter");
  return test(name + " with nothing to apply to is an error", function(){
    return this.throws(function(){
      return parse("(" + c + ")");
    }, sexpr.SyntaxError);
  });
});
charEscape = function(it){
  switch (it) {
  case '\n':
    return "\\n";
  case '\t':
    return "\\t";
  case '\r':
    return "\\r";
  default:
    return it;
  }
};
['\'', '`', '"', ';', '\\', " ", '"', "\n", "\t"].forEach(function(c){
  return to("a\\" + c + "b", ["a" + c + "b"])("escaped " + charEscape(c) + " in an atom should parse");
});
['"', "\\"].forEach(function(c){
  return to("\"a\\" + c + "b\"", [new String("a" + c + "b")])("escaped " + charEscape(c) + " in a string should parse");
});
[['b', "\b"], ['f', "\f"], ['n', "\n"], ['r', "\r"], ['t', "\t"], ['v', "\v"], ['0', "\0"]].forEach(function(arg$){
  var char, escapedChar;
  char = arg$[0], escapedChar = arg$[1];
  return to("\"a\\" + char + "b\"", [new String("a" + escapedChar + "b")])("strings may contain \\" + char + " escape");
});
test("special characters work", function(){
  return ['+', '/', '*', '£', '$', '%', '^', '&', 'あ'].forEach(function(it){
    return to(it, [it])("special character " + it + " works as atom");
  });
});
to(";hi", [])("only 1 comment");
to(";hi\na", ["a"])("comment, then atom");
to(";hi\n;yo", [])("only comments");
to("(\n; a\n;b\n\n)", [[]])("empty list with comments inside");
to("();hi", [[]])("comment immediately following list");
to("a;hi", ["a"])("comment immediately following atom");
to(";(a comment)", [])("comment looking like a form");
to("(a ;)\nb)", [['a', 'b']])("form with close-paren-looking comment between");
to('("a ;)"\n)', [[new String("a ;)")]])("can't start comment in string");
testWithModifications("Transformer can change paren style", "[a b c]", [['a', 'b', 'c']], function(p){
  partser.replace(p.expression.list.opener, partser.string('['));
  return partser.replace(p.expression.list.closer, partser.string(']'));
});
testWithModifications("Transformer can reverse atoms", "olleh ereht", ['hello', 'there'], function(p){
  return partser.replace(p.expression.atom, partser.map(partser.clone(p.expression.atom), function(it){
    it.content = it.content.split("").reverse().join("");
    return it;
  }));
});
testWithModifications("Transformer can add alternative way of writing atom", "$a b", ['a', 'b'], function(p){
  var dollarThenAtom, this$ = this;
  dollarThenAtom = partser.map(partser.seq(partser.string('$'), p.expression.atom), function(it){
    return it[1];
  });
  return partser.replace(p.expression.atom, partser.alt(dollarThenAtom, partser.clone(p.expression.atom)));
});
testWithModifications("Transformer can introduce alternative parsing rules", '(f [a b c xyz\\[\\]])', [['f', ['array', 'a', 'b', 'c', 'xyz[]']]], function(p){
  var string, arrayOpener, arrayTerminator, squareBracketsArrayParser, this$ = this;
  string = partser.string;
  arrayOpener = p.lexeme(string('['));
  arrayTerminator = p.lexeme(string(']'));
  squareBracketsArrayParser = partser.map(partser.mark(partser.map(partser.seq(arrayOpener, p.expression.list.content, arrayTerminator), function(it){
    return it[1];
  })), function(it){
    it.value.unshift({
      type: 'atom',
      content: 'array',
      location: {
        start: it.start,
        end: it.start
      }
    });
    return {
      type: 'list',
      content: it.value,
      location: {
        start: it.start,
        end: it.end
      }
    };
  });
  partser.replace(p.expression, partser.alt(squareBracketsArrayParser, partser.clone(p.expression)));
  return partser.replace(p.expression.atom.charNeedingEscape, partser.alt(string('['), string(']'), partser.clone(p.expression.atom.charNeedingEscape)));
});
testWithModifications("Transformer can add ASCII char escape type to strings", '"\\t\\x20"', [new String("\t ")], function(p){
  var asciiEscape;
  asciiEscape = partser.map(partser.seq(p.escapeChar, partser.string('x'), partser.regex(/[0-9a-f]+/)), function(arg$){
    var _, it;
    _ = arg$[0], _ = arg$[1], it = arg$[2];
    return String.fromCharCode(
    parseInt(it, 16));
  });
  return partser.replace(p.expression.string.escapedCharacter, partser.alt(asciiEscape, partser.clone(p.expression.string.escapedCharacter)));
});
test("lone atom loc is correct", function(){
  var x$, y$, z$, z1$, z2$;
  x$ = parse("hi");
  this.equals(toString$.call(x$).slice(8, -1), 'Array');
  x$.length === 1;
  y$ = x$[0];
  this.equals(y$.type, 'atom');
  z$ = y$.location;
  z1$ = z$.start;
  this.equals(z1$.offset, 0);
  this.equals(z1$.line, 1);
  this.equals(z1$.column, 1);
  z2$ = z$.end;
  this.equals(z2$.offset, 2);
  this.equals(z2$.line, 1);
  this.equals(z2$.column, 3);
  return x$;
});
test("single-line string loc is correct", function(){
  var x$, y$, z$, z1$, z2$;
  x$ = parse('"hi"');
  this.equals(toString$.call(x$).slice(8, -1), 'Array');
  x$.length === 1;
  y$ = x$[0];
  this.equals(y$.type, 'string');
  z$ = y$.location;
  z1$ = z$.start;
  this.equals(z1$.offset, 0);
  this.equals(z1$.line, 1);
  this.equals(z1$.column, 1);
  z2$ = z$.end;
  this.equals(z2$.offset, 4);
  this.equals(z2$.line, 1);
  this.equals(z2$.column, 5);
  return x$;
});
test("multi-line string loc is correct", function(){
  var x$, y$, z$, z1$, z2$;
  x$ = parse('"hi\nthere"');
  this.equals(toString$.call(x$).slice(8, -1), 'Array');
  x$.length === 1;
  y$ = x$[0];
  this.equals(y$.type, 'string');
  z$ = y$.location;
  z1$ = z$.start;
  this.equals(z1$.offset, 0);
  this.equals(z1$.line, 1);
  this.equals(z1$.column, 1);
  z2$ = z$.end;
  this.equals(z2$.offset, 10);
  this.equals(z2$.line, 2);
  this.equals(z2$.column, 7);
  return x$;
});
test("string containing escapes has correct loc", function(){
  var x$, y$, z$, z1$, z2$;
  x$ = parse('"\\n\\t"');
  this.equals(toString$.call(x$).slice(8, -1), 'Array');
  x$.length === 1;
  y$ = x$[0];
  this.equals(y$.type, 'string');
  z$ = y$.location;
  z1$ = z$.start;
  this.equals(z1$.offset, 0);
  this.equals(z1$.line, 1);
  this.equals(z1$.column, 1);
  z2$ = z$.end;
  this.equals(z2$.offset, 6);
  this.equals(z2$.line, 1);
  this.equals(z2$.column, 7);
  return x$;
});
test("empty list loc is correct", function(){
  var x$, y$, z$, z1$, z2$;
  x$ = parse('()');
  this.equals(toString$.call(x$).slice(8, -1), 'Array');
  x$.length === 1;
  y$ = x$[0];
  this.equals(y$.type, 'list');
  z$ = y$.location;
  z1$ = z$.start;
  this.equals(z1$.offset, 0);
  this.equals(z1$.line, 1);
  this.equals(z1$.column, 1);
  z2$ = z$.end;
  this.equals(z2$.offset, 2);
  this.equals(z2$.line, 1);
  this.equals(z2$.column, 3);
  return x$;
});
test("2-element list loc is correct", function(){
  var x$, y$, z$, z1$, z2$;
  x$ = parse('(a b)');
  this.equals(toString$.call(x$).slice(8, -1), 'Array');
  x$.length === 1;
  y$ = x$[0];
  this.equals(y$.type, 'list');
  z$ = y$.location;
  z1$ = z$.start;
  this.equals(z1$.offset, 0);
  this.equals(z1$.line, 1);
  this.equals(z1$.column, 1);
  z2$ = z$.end;
  this.equals(z2$.offset, 5);
  this.equals(z2$.line, 1);
  this.equals(z2$.column, 6);
  return x$;
});
test("2-element list content loc is correct", function(){
  var x$, y$, z$, z1$, z2$, z3$, z4$, z5$, z6$, z7$, z8$;
  x$ = parse('(a b)');
  this.equals(toString$.call(x$).slice(8, -1), 'Array');
  x$.length === 1;
  y$ = x$[0];
  this.equals(y$.type, 'list');
  z$ = y$.content;
  z1$ = z$[0];
  this.equals(z1$.type, 'atom');
  z2$ = z1$.location;
  z3$ = z2$.start;
  this.equals(z3$.offset, 1);
  this.equals(z3$.line, 1);
  this.equals(z3$.column, 2);
  z4$ = z2$.end;
  this.equals(z4$.offset, 2);
  this.equals(z4$.line, 1);
  this.equals(z4$.column, 3);
  z5$ = z$[1];
  this.equals(z5$.type, 'atom');
  z6$ = z5$.location;
  z7$ = z6$.start;
  this.equals(z7$.offset, 3);
  this.equals(z7$.line, 1);
  this.equals(z7$.column, 4);
  z8$ = z6$.end;
  this.equals(z8$.offset, 4);
  this.equals(z8$.line, 1);
  this.equals(z8$.column, 5);
  return x$;
});
test("quote atom loc matches that of the quote character", function(){
  var this$ = this;
  return [['\'', 'quote'], ['`', 'quasiquote'], [',', 'unquote'], [',@', 'unquote-splicing']].forEach(function(arg$){
    var c, name, x$, y$, z$, z1$, z2$, z3$;
    c = arg$[0], name = arg$[1];
    x$ = parse(c + "a");
    this$.equals(toString$.call(x$).slice(8, -1), 'Array');
    x$.length === 1;
    y$ = x$[0];
    this$.equals(y$.type, 'list');
    z$ = y$.content[0];
    this$.equals(z$.type, 'atom');
    this$.equals(z$.content, name);
    z1$ = z$.location;
    z2$ = z1$.start;
    this$.equals(z2$.offset, 0);
    this$.equals(z2$.line, 1);
    this$.equals(z2$.column, 1);
    z3$ = z1$.end;
    this$.equals(z3$.offset, c.length);
    this$.equals(z3$.line, 1);
    this$.equals(z3$.column, 1 + c.length);
    return x$;
  });
});
test("quoted list locations match", function(){
  var this$ = this;
  return [['\'', 'quote'], ['`', 'quasiquote'], [',', 'unquote'], [',@', 'unquote-splicing']].forEach(function(arg$){
    var c, name, x$, y$, z$, z1$, z2$, z3$;
    c = arg$[0], name = arg$[1];
    this$.comment(name + ":");
    x$ = parse(c + "()");
    this$.equals(toString$.call(x$).slice(8, -1), 'Array');
    x$.length === 1;
    y$ = x$[0];
    this$.equals(y$.type, 'list');
    z$ = y$.content[0];
    this$.equals(z$.type, 'atom');
    this$.equals(z$.content, name);
    z1$ = y$.location;
    z2$ = z1$.start;
    this$.equals(z2$.offset, 0);
    this$.equals(z2$.line, 1);
    this$.equals(z2$.column, 1);
    z3$ = z1$.end;
    this$.equals(z3$.offset, c.length + 2);
    this$.equals(z3$.line, 1);
    this$.equals(z3$.column, c.length + 3);
    return x$;
  });
});
test("locations of multi-form parse are correct", function(){
  var x$, y$, z$, z1$, z2$, z3$, z4$, z5$, z6$, z7$, z8$, z9$, z10$, z11$, z12$, z13$, z14$;
  x$ = parse('(a b) (c)');
  this.equals(toString$.call(x$).slice(8, -1), 'Array');
  x$.length === 2;
  y$ = x$[0];
  this.equals(y$.type, 'list');
  z$ = y$.content;
  z1$ = z$[0];
  this.equals(z1$.type, 'atom');
  z2$ = z1$.location;
  z3$ = z2$.start;
  this.equals(z3$.offset, 1);
  this.equals(z3$.line, 1);
  this.equals(z3$.column, 2);
  z4$ = z2$.end;
  this.equals(z4$.offset, 2);
  this.equals(z4$.line, 1);
  this.equals(z4$.column, 3);
  z5$ = z$[1];
  this.equals(z5$.type, 'atom');
  z6$ = z5$.location;
  z7$ = z6$.start;
  this.equals(z7$.offset, 3);
  this.equals(z7$.line, 1);
  this.equals(z7$.column, 4);
  z8$ = z6$.end;
  this.equals(z8$.offset, 4);
  this.equals(z8$.line, 1);
  this.equals(z8$.column, 5);
  z9$ = x$[1];
  this.equals(z9$.type, 'list');
  z10$ = z9$.content;
  z11$ = z10$[0];
  this.equals(z11$.type, 'atom');
  z12$ = z11$.location;
  z13$ = z12$.start;
  this.equals(z13$.offset, 7);
  this.equals(z13$.line, 1);
  this.equals(z13$.column, 8);
  z14$ = z12$.end;
  this.equals(z14$.offset, 8);
  this.equals(z14$.line, 1);
  this.equals(z14$.column, 9);
  return x$;
});
test("closing after the end is an error", function(){
  return this.throws(function(){
    return parse("())");
  }, sexpr.SyntaxError);
});
test("incomplete string is an error", function(){
  return this.throws(function(){
    return parse('"a');
  }, sexpr.SyntaxError);
});
test("incomplete form due to comment is an error", function(){
  return this.throws(function(){
    return parse('(a;)');
  }, sexpr.SyntaxError);
});
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}