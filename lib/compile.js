// Generated by LiveScript 1.5.0
var looksLikePositiveNumber, looksLikeNegativeNumber, stringToEstree, stringToSelfProducer, atomToEstree, atomToSelfProducer, listToSelfProducer, listToEstree, astToEstree, astToSelfProducer, x$, slice$ = [].slice, toString$ = {}.toString;
looksLikePositiveNumber = function(atomText){
  return atomText.match(/^\d+(\.\d+)?$/);
};
looksLikeNegativeNumber = function(atomText){
  return atomText.match(/^-\d+(\.\d+)?$/);
};
stringToEstree = function(env, ast){
  var value;
  value = ast.value;
  return {
    type: 'Literal',
    value: value,
    raw: "\"" + value + "\"",
    loc: ast.location
  };
};
stringToSelfProducer = function(it){
  return {
    type: 'ObjectExpression',
    properties: [
      {
        type: 'Property',
        kind: 'init',
        key: {
          type: 'Identifier',
          name: 'type'
        },
        value: {
          type: 'Literal',
          value: 'string',
          raw: "\"string\""
        }
      }, {
        type: 'Property',
        kind: 'init',
        key: {
          type: 'Identifier',
          name: 'value'
        },
        value: {
          type: 'Literal',
          value: it,
          raw: "\"" + it + "\""
        }
      }
    ]
  };
};
atomToEstree = function(env, ast){
  var name, lit, this$ = this;
  name = ast.value;
  lit = function(it){
    return {
      type: 'Literal',
      value: it,
      raw: name,
      loc: ast.location
    };
  };
  switch (name) {
  case 'this':
    return {
      type: 'ThisExpression'
    };
  case 'null':
    return lit(null);
  case 'true':
    return lit(true);
  case 'false':
    return lit(false);
  default:
    switch (false) {
    case !looksLikePositiveNumber(name):
      return {
        type: 'Literal',
        value: Number(name),
        raw: name,
        loc: ast.location
      };
    case !looksLikeNegativeNumber(name):
      return {
        type: 'UnaryExpression',
        operator: '-',
        prefix: true,
        argument: lit(Number(name.slice(1)))
      };
    default:
      return {
        type: 'Identifier',
        name: name,
        loc: ast.location
      };
    }
  }
};
atomToSelfProducer = function(it){
  return {
    type: 'ObjectExpression',
    properties: [
      {
        type: 'Property',
        kind: 'init',
        key: {
          type: 'Identifier',
          name: 'type'
        },
        value: {
          type: 'Literal',
          value: 'atom',
          raw: "\"atom\""
        }
      }, {
        type: 'Property',
        kind: 'init',
        key: {
          type: 'Identifier',
          name: 'value'
        },
        value: {
          type: 'Literal',
          value: it,
          raw: "\"" + it + "\""
        }
      }
    ]
  };
};
listToSelfProducer = function(env, arg$){
  var values;
  values = arg$.values;
  return {
    type: 'ObjectExpression',
    properties: [
      {
        type: 'Property',
        kind: 'init',
        key: {
          type: 'Identifier',
          name: 'type'
        },
        value: {
          type: 'Literal',
          value: 'list',
          raw: "\"list\""
        }
      }, {
        type: 'Property',
        kind: 'init',
        key: {
          type: 'Identifier',
          name: 'values'
        },
        value: {
          type: 'ArrayExpression',
          elements: values.map(partialize$.apply(this, [astToSelfProducer, [env, void 8], [1]]))
        }
      }
    ]
  };
};
listToEstree = function(env, ast, options){
  var values, head, rest, localEnv, r, that, macroReturn, e, line, column;
  values = ast.values;
  options == null && (options = {});
  if (values.length === 0) {
    return {
      type: 'Literal',
      value: null,
      raw: 'null',
      loc: ast.location
    };
  }
  head = values[0], rest = slice$.call(values, 1);
  if (!head) {
    return null;
  }
  localEnv = env.derive();
  r = (that = head.type === 'atom' && localEnv.findMacro(head.value))
    ? (void 8, (function(){
      var ref$;
      try {
        return macroReturn = that.apply(localEnv, rest);
      } catch (e$) {
        e = e$;
        ref$ = ast.location.start, line = ref$.line, column = ref$.column;
        e.message = "Error evaluating macro `" + head.value + "` (called at line " + line + ", column " + column + "): " + e.message;
        throw e;
      }
    }()), (function(){
      var ref$, x$, y$;
      switch (that = toString$.call(macroReturn).slice(8, -1)) {
      case 'Null':
        // fallthrough
      case 'Undefined':
        return null;
      case 'Array':
        macroReturn.forEach(function(it){
          var that;
          switch (that = toString$.call(it).slice(8, -1)) {
          case 'Object':
            break;
          default:
            throw Error("Unexpected `" + that + "` value received in multi-return");
          }
        });
        return macroReturn.map(function(it){
          var x$;
          x$ = astToEstree(env, it);
          if (x$ != null) {
            x$.loc || (x$.loc = head.location);
          }
          return x$;
        });
      case 'Object':
        if ((ref$ = macroReturn.type) === 'atom' || ref$ === 'list' || ref$ === 'string') {
          x$ = astToEstree(env, macroReturn);
          if (x$ != null) {
            x$.loc || (x$.loc = head.location);
          }
          return x$;
        } else {
          y$ = macroReturn;
          if (y$ != null) {
            y$.loc || (y$.loc = head.location);
          }
          return y$;
        }
        break;
      default:
        throw Error("Unexpected macro return type " + that);
      }
    }()))
    : {
      type: 'CallExpression',
      callee: astToEstree(env, head),
      arguments: rest.map(partialize$.apply(this, [astToEstree, [env, void 8], [1]])),
      loc: ast.location
    };
  return r;
};
astToEstree = function(env, ast, options){
  switch (ast.type) {
  case 'atom':
    return atomToEstree.apply(null, arguments);
  case 'string':
    return stringToEstree.apply(null, arguments);
  case 'list':
    return listToEstree.apply(null, arguments);
  default:
    return ast;
  }
};
astToSelfProducer = function(env, ast){
  switch (ast.type) {
  case 'atom':
    return atomToSelfProducer(ast.value);
  case 'string':
    return stringToSelfProducer(ast.value);
  case 'list':
    return listToSelfProducer(env, ast);
  }
};
x$ = module.exports = astToEstree;
x$.toSelfProducer = astToSelfProducer;
function partialize$(f, args, where){
  var context = this;
  return function(){
    var params = slice$.call(arguments), i,
        len = params.length, wlen = where.length,
        ta = args ? args.concat() : [], tw = where ? where.concat() : [];
    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
    return len < wlen && len ?
      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);
  };
}