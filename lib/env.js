// Generated by LiveScript 1.5.0
var ref$, keys, concatMap, unfoldr, map, reverse, fold, esGenerate, compile, findMacro, flattenMacroTable, cloneArray, findRoot, env, slice$ = [].slice, this$ = this;
ref$ = require('prelude-ls'), keys = ref$.keys, concatMap = ref$.concatMap, unfoldr = ref$.unfoldr, map = ref$.map, reverse = ref$.reverse, fold = ref$.fold;
esGenerate = partialize$.apply(require('escodegen'), [require('escodegen').generate, [void 8], [0]]);
compile = require('./compile');
findMacro = function(macroTable, name){
  var that;
  switch (that = macroTable.contents[name]) {
  case null:
    return null;
  case undefined:
    if (macroTable.parent) {
      return findMacro(macroTable.parent, name);
    } else {
      return null;
    }
    break;
  default:
    return that;
  }
};
flattenMacroTable = function(table){
  var this$ = this;
  return function(it){
    return {
      parent: {
        contents: it,
        parent: null
      },
      contents: {}
    };
  }(
  fold(curry$(function(x$, y$){
    return import$(x$, y$);
  }), {})(
  reverse(
  map(function(it){
    return it.contents;
  })(
  unfoldr(function(it){
    if (it) {
      return [it, it.parent];
    }
  })(
  table)))));
};
cloneArray = function(it){
  return it.slice(0);
};
findRoot = function(macroTable){
  var parent, that;
  parent = macroTable.parent;
  switch (false) {
  case !(that = parent):
    return findRoot(that);
  default:
    return macroTable;
  }
};
env = (function(){
  env.displayName = 'env';
  var prototype = env.prototype, constructor = env;
  function env(rootTable, options){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    rootTable == null && (rootTable = null);
    options == null && (options = {});
    this$.importMacro = bind$(this$, 'importMacro', prototype);
    this$.findMacro = bind$(this$, 'findMacro', prototype);
    this$.deriveRoot = bind$(this$, 'deriveRoot', prototype);
    this$.deriveFlattened = bind$(this$, 'deriveFlattened', prototype);
    this$.derive = bind$(this$, 'derive', prototype);
    this$.evaluate = bind$(this$, 'evaluate', prototype);
    this$.compileMany = bind$(this$, 'compileMany', prototype);
    this$.compileToQuote = bind$(this$, 'compileToQuote', prototype);
    this$.compile = bind$(this$, 'compile', prototype);
    this$.macroTable = {
      contents: {},
      parent: rootTable
    };
    this$.rootTable = rootTable;
    this$.filename = options.filename || null;
    this$.importTargetMacroTables = options.importTargetMacroTables;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  env.prototype.atom = function(value){
    return {
      type: 'atom',
      value: value.toString()
    };
  };
  env.prototype.string = function(value){
    return {
      type: 'string',
      value: value
    };
  };
  env.prototype.list = function(){
    var values, res$, i$, to$;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    values = res$;
    return {
      type: 'list',
      values: values
    };
  };
  env.prototype.compile = function(it){
    return compile(this, it);
  };
  env.prototype.compileToQuote = function(it){
    return compile.toSelfProducer(this, it);
  };
  env.prototype.compileMany = function(it){
    var this$ = this;
    return function(it){
      return it.filter((function(it){
        return it !== null;
      }));
    }(
    concatMap(this.compile)(
    it));
  };
  env.prototype.compileToJs = function(it){
    return esGenerate(it);
  };
  env.prototype.evaluate = function(it){
    var ast, js;
    ast = this.compile(
    it);
    js = this.compileToJs(
    ast);
    if (ast.type === 'ObjectExpression') {
      return eval(
      function(it){
        return "(" + it + ")";
      }(
      js));
    } else {
      return eval(
      js);
    }
  };
  env.prototype.derive = function(){
    return env(this.macroTable, {
      importTargetMacroTables: this.importTargetMacroTables,
      filename: this.filename
    });
  };
  env.prototype.deriveFlattened = function(){
    var flattenedMacroTable, tableToReadFrom, tablesToImportInto, that, x$;
    flattenedMacroTable = flattenMacroTable(this.macroTable);
    tableToReadFrom = flattenedMacroTable;
    tablesToImportInto = (that = this.importTargetMacroTables)
      ? cloneArray(that)
      : [this.macroTable];
    x$ = tablesToImportInto;
    x$.push(flattenedMacroTable);
    return env(tableToReadFrom, {
      importTargetMacroTables: tablesToImportInto,
      filename: this.filename
    });
  };
  env.prototype.deriveRoot = function(){
    var rootTable, importTargets;
    rootTable = findRoot(this.macroTable);
    importTargets = this.importTargetMacroTables || [this.macroTable];
    return env(rootTable, {
      importTargetMacroTables: importTargets
    });
  };
  env.prototype.findMacro = function(name){
    return findMacro(this.macroTable, name);
  };
  env.prototype.importMacro = function(name, func){
    var that, this$ = this;
    if (that = this.importTargetMacroTables) {
      return that.forEach(function(it){
        return it.parent.contents[name] = func;
      });
    } else {
      return this.macroTable.parent.contents[name] = func;
    }
  };
  return env;
}());
module.exports = env;
function partialize$(f, args, where){
  var context = this;
  return function(){
    var params = slice$.call(arguments), i,
        len = params.length, wlen = where.length,
        ta = args ? args.concat() : [], tw = where ? where.concat() : [];
    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
    return len < wlen && len ?
      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);
  };
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}