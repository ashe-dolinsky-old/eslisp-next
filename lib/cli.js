// Generated by LiveScript 1.5.0
var concat, zip, spawn, esl, fs, path, nopt, chalk, convertSourceMap, InvalidAstError, printVersion, printUsage, options, optionShorthands, parsedOptions, exitAfter, targetPath, compilerOpts, that, compileAndShow, stringSplice, pointAtProblem, statefulCompiler, repl, vm, toString$ = {}.toString;
concat = require('concat-stream');
zip = require('prelude-ls').zip;
spawn = require('child_process').spawn;
esl = require('./index');
fs = require('fs');
path = require('path');
nopt = require('nopt');
chalk = require('chalk');
convertSourceMap = require('convert-source-map');
InvalidAstError = require('esvalid').InvalidAstError;
printVersion = function(){
  var e;
  try {
    console.log(require('../package.json').version);
    return process.exit(0);
  } catch (e$) {
    e = e$;
    console.error(e);
    console.error("Unknown version; error reading or parsing package.json");
    return process.exit(1);
  }
};
printUsage = function(){
  return console.log("Usage: eslc [-h] [-v] [-t require-path] [-s MAP-FILE] [-S] [FILE]\n  FILE                      eslisp file (if omitted, stdin is read)\n  -v, --version             print version, exit\n  -h, --help                print usage, exit\n  -t, --transform           macro to `require` and wrap whole input in; can\n                              be specified multiple times\n  -s, --source-map-outfile  file to save source map in; remember to add the\n                              appropriate `//# sourceMappingURL=...` comment\n                              to the end of your output JS file\n  -S, --embed-source-map    store source map in the generated output JS");
};
options = {
  version: Boolean,
  help: Boolean,
  transform: Array,
  'source-map-outfile': String,
  'embed-source-map': Boolean
};
optionShorthands = {
  v: '--version',
  h: '--help',
  t: '--transform',
  s: '--source-map-outfile',
  S: '--embed-source-map'
};
parsedOptions = nopt(options, optionShorthands, process.argv);
if (parsedOptions.version) {
  printVersion();
  exitAfter = true;
}
if (parsedOptions.help) {
  printUsage();
  exitAfter = true;
}
if (exitAfter) {
  process.exit();
}
targetPath = null;
parsedOptions.argv.remain.forEach(function(it){
  if (targetPath) {
    console.error("Too many arguments (expected 0 or 1 files)");
    return process.exit(2);
  } else {
    return targetPath = it;
  }
});
compilerOpts = {};
if (that = parsedOptions.transform) {
  compilerOpts.transformMacros = that.map(require);
}
compileAndShow = function(code, filename){
  var optMapOut, optMapEmbed, jsCode, jsMap, ref$, map, that, sourceMapDataUriComment, err;
  filename == null && (filename = null);
  code = code.toString();
  try {
    optMapOut = parsedOptions['source-map-outfile'];
    optMapEmbed = parsedOptions['embed-source-map'];
    compilerOpts.filename = filename;
    if (optMapOut || optMapEmbed) {
      ref$ = esl.withSourceMap(code, compilerOpts), code = ref$.code, map = ref$.map;
      jsCode = code;
      jsMap = map;
    } else {
      jsCode = esl(code, compilerOpts);
      jsMap = null;
    }
    if (that = optMapOut) {
      fs.writeFile(that, map, function(e){
        var that;
        if (that = e) {
          console.error("Error writing to source map output file " + that);
          return process.exit(5);
        }
      });
    }
    if (optMapEmbed) {
      sourceMapDataUriComment = convertSourceMap.fromJSON(jsMap).toComment();
      jsCode += "\n" + sourceMapDataUriComment;
    }
    return console.log(jsCode);
  } catch (e$) {
    err = e$;
    if (err instanceof InvalidAstError) {
      console.error(chalk.red("[Error]") + " " + err.message);
      return pointAtProblem(code, err.node);
    } else {
      throw err;
    }
  }
};
stringSplice = function(string, start, end, insertedText){
  insertedText == null && (insertedText = "");
  return string.slice(0, start) + insertedText + string.slice(end, string.length);
};
pointAtProblem = function(input, problematicNode){
  var location, stringifiedNode, start, end, lines, startOffset, endOffset, highlightedPart, highlightedLines;
  location = problematicNode.loc;
  switch (toString$.call(location).slice(8, -1)) {
  case 'String':
    stringifiedNode = JSON.stringify(problematicNode, function(k, v){
      if (k === 'location') {
        return undefined;
      } else {
        return v;
      }
    });
    console.error("  " + stringifiedNode);
    return console.error(chalk.yellow("  [ " + location + " ]"));
  case 'Object':
    start = location.start, end = location.end;
    lines = input.split("\n").slice(start.line - 1, end.line).join("\n");
    startOffset = start.offset;
    endOffset = end.offset;
    highlightedPart = chalk.black.bgYellow(lines.slice(startOffset, endOffset));
    highlightedLines = stringSplice(lines, startOffset, endOffset, highlightedPart);
    console.error("At line " + chalk.green(start.line) + ", offset " + chalk.green(startOffset) + ":");
    return console.error("\n" + highlightedLines + "\n");
  default:
    throw Error("Internal error: unexpected location type");
  }
};
if (targetPath) {
  fs.readFile(targetPath, {
    encoding: 'utf8'
  }, function(e, eslCode){
    if (e) {
      throw e;
    }
    return compileAndShow(eslCode, targetPath);
  });
} else {
  if (!process.stdin.isTTY) {
    if (parsedOptions['source-map-outfile']) {
      console.error("Given --source-map-outfile flag, but code was input on stdin\ninstead of by file path.  Source maps require a file name:\nplease specify the input file by a filename.");
      process.exit(3);
    }
    process.stdin.pipe(concat(compileAndShow));
  } else {
    statefulCompiler = esl.stateful(compilerOpts);
    repl = require('repl');
    vm = require('vm');
    repl.start({
      prompt: "> ",
      useGlobal: true,
      eval: function(cmd, context, filename, callback){
        var err;
        try {
          return callback(null, vm.runInThisContext(
          statefulCompiler(cmd)));
        } catch (e$) {
          err = e$;
          if (err instanceof InvalidAstError) {
            console.error(chalk.red("[Error]") + " " + err.message);
            pointAtProblem(cmd, err.node);
            return callback(null);
          } else {
            throw err;
          }
        }
      }
    });
  }
}