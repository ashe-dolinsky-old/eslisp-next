// Generated by LiveScript 1.5.0
var ref$, map, zip, concatMap, isExpression, statementify, importCompilerspaceMacro, multipleStatements, Module, path, chainedBinaryExpr, unaryExpr, nAryExpr, updateExpression, quote, optionallyImplicitBlockStatement, functionType, compileUnlessEmptyList, contents, isComputedProperty, dot, get, isPart, qqBody, generateConcat, qq, slice$ = [].slice, toString$ = {}.toString;
ref$ = require('prelude-ls'), map = ref$.map, zip = ref$.zip, concatMap = ref$.concatMap;
isExpression = require('esutils').ast.isExpression;
statementify = require('./es-statementify');
ref$ = require('./import-macro'), importCompilerspaceMacro = ref$.importCompilerspaceMacro, multipleStatements = ref$.multipleStatements;
Module = require('module');
path = require('path');
chainedBinaryExpr = function(type, operator, associativity){
  var macro;
  associativity == null && (associativity = 'right');
  macro = function(){
    var head, rest, res$, i$, to$, firstFew, j$, last;
    switch (false) {
    case arguments.length !== 0:
      throw Error("binary expression macro `" + operator + "` unexpectedly called with no arguments");
    case arguments.length !== 1:
      return this.compile(arguments[0]);
    case arguments.length !== 2:
      return {
        type: type,
        operator: operator,
        left: this.compile(arguments[0]),
        right: this.compile(arguments[1])
      };
    default:
      switch (associativity) {
      case 'right':
        head = arguments[0]; res$ = [];
        for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
          res$.push(arguments[i$]);
        }
        rest = res$;
        return macro.call(this, macro.call(this, this.compile(head)), macro.apply(this, rest));
      case 'left':
        res$ = [];
        for (j$ = 0 < (i$ = arguments.length - 1) ? 0 : (i$ = 0); j$ < i$; ++j$) {
          res$.push(arguments[j$]);
        }
        firstFew = res$; last = arguments[i$];
        return macro.call(this, macro.apply(this, firstFew), macro.call(this, this.compile(last)));
      }
    }
  };
  return function(){
    if (arguments.length === 1) {
      throw Error("Chained binary expression `" + operator + "` unexpectedly called with 1 argument");
    } else {
      return macro.apply(this, arguments);
    }
  };
};
unaryExpr = function(operator){
  return function(arg){
    return {
      type: 'UnaryExpression',
      operator: operator,
      prefix: true,
      argument: this.compile(arg)
    };
  };
};
nAryExpr = function(operator, associativity){
  var nAry, unary;
  associativity == null && (associativity = 'right');
  nAry = chainedBinaryExpr('BinaryExpression', operator, associativity);
  unary = unaryExpr(operator);
  return function(){
    switch (arguments.length) {
    case 0:
      throw Error(operator + " requires at least 1 argument");
    case 1:
      return unary.apply(this, arguments);
    default:
      return nAry.apply(this, arguments);
    }
  };
};
updateExpression = function(operator, arg$){
  var type, isPrefix;
  type = arg$.type;
  if (operator !== '++' && operator !== '--') {
    throw Error("Illegal update expression operator " + operator);
  }
  isPrefix = type === 'prefix';
  return function(value){
    if (arguments.length !== 1) {
      throw Error("Expected `++` expression to get exactly 1 argument but got " + arguments.length);
    }
    return {
      type: 'UpdateExpression',
      operator: operator,
      prefix: isPrefix,
      argument: this.compile(value)
    };
  };
};
quote = function(item){
  switch (false) {
  case !(arguments.length > 1):
    throw Error("Too many arguments to quote; expected 1 but got " + arguments.length);
  case !item:
    return this.compileToQuote(item);
  default:
    return this.compileToQuote({
      type: 'list',
      values: [],
      location: "returned from macro"
    });
  }
};
optionallyImplicitBlockStatement = function(arg$, body){
  var compile, compileMany, bodyCompiled;
  compile = arg$.compile, compileMany = arg$.compileMany;
  if (body.length === 1) {
    bodyCompiled = compile(body[0]);
    if (bodyCompiled.type === 'BlockStatement') {
      return bodyCompiled;
    }
  }
  return {
    type: 'BlockStatement',
    body: compileMany(body).map(statementify)
  };
};
functionType = function(type){
  return function(params){
    var rest, res$, i$, to$, id;
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    rest = res$;
    if (params.type === 'atom') {
      id = {
        type: 'Identifier',
        name: params.value
      };
      params = rest.shift().values.map(this.compile);
    } else {
      id = null;
      params = params.values.map(this.compile);
    }
    return {
      type: type,
      id: id,
      params: params,
      body: optionallyImplicitBlockStatement(this, rest)
    };
  };
};
compileUnlessEmptyList = function(compile, ast){
  if (ast.type !== 'list') {
    throw Error("Unexpected argument AST; expected list");
  }
  if (ast.values.length) {
    return compile(ast);
  } else {
    return null;
  }
};
contents = {
  '+': nAryExpr('+', 'left'),
  '-': nAryExpr('-', 'left'),
  '*': chainedBinaryExpr('BinaryExpression', '*', 'left'),
  '/': chainedBinaryExpr('BinaryExpression', '/', 'left'),
  '%': chainedBinaryExpr('BinaryExpression', '%', 'left'),
  '++': updateExpression('++', {
    type: 'prefix'
  }),
  '++_': updateExpression('++', {
    type: 'prefix'
  }),
  '_++': updateExpression('++', {
    type: 'suffix'
  }),
  '--': updateExpression('--', {
    type: 'prefix'
  }),
  '--_': updateExpression('--', {
    type: 'prefix'
  }),
  '_--': updateExpression('--', {
    type: 'suffix'
  }),
  '&&': chainedBinaryExpr('LogicalExpression', '&&', 'left'),
  '||': chainedBinaryExpr('LogicalExpression', '||', 'left'),
  '!': unaryExpr('!'),
  '<': chainedBinaryExpr('BinaryExpression', '<', 'left'),
  '>': chainedBinaryExpr('BinaryExpression', '>', 'left'),
  '<=': chainedBinaryExpr('BinaryExpression', '<=', 'left'),
  '>=': chainedBinaryExpr('BinaryExpression', '>=', 'left'),
  'delete': unaryExpr('delete'),
  'typeof': unaryExpr('typeof'),
  'void': unaryExpr('void'),
  'instanceof': chainedBinaryExpr('BinaryExpression', 'instanceof', 'left'),
  'in': chainedBinaryExpr('BinaryExpression', 'in', 'left'),
  '&': chainedBinaryExpr('BinaryExpression', '&', 'left'),
  '|': chainedBinaryExpr('BinaryExpression', '|', 'left'),
  '^': chainedBinaryExpr('BinaryExpression', '^', 'left'),
  '>>': chainedBinaryExpr('BinaryExpression', '>>', 'left'),
  '<<': chainedBinaryExpr('BinaryExpression', '<<', 'left'),
  '>>>': chainedBinaryExpr('BinaryExpression', '>>>', 'left'),
  '~': unaryExpr('~'),
  '==': chainedBinaryExpr('BinaryExpression', '==', 'left'),
  '!=': chainedBinaryExpr('BinaryExpression', '!=', 'left'),
  '===': chainedBinaryExpr('BinaryExpression', '===', 'left'),
  '!==': chainedBinaryExpr('BinaryExpression', '!==', 'left'),
  '=': chainedBinaryExpr('AssignmentExpression', '='),
  '+=': chainedBinaryExpr('AssignmentExpression', '+='),
  '-=': chainedBinaryExpr('AssignmentExpression', '-='),
  '*=': chainedBinaryExpr('AssignmentExpression', '*='),
  '/=': chainedBinaryExpr('AssignmentExpression', '/='),
  '%=': chainedBinaryExpr('AssignmentExpression', '%='),
  '>>=': chainedBinaryExpr('AssignmentExpression', '>>='),
  '<<=': chainedBinaryExpr('AssignmentExpression', '<<='),
  '>>>=': chainedBinaryExpr('AssignmentExpression', '>>>='),
  '&=': chainedBinaryExpr('AssignmentExpression', '&='),
  '|=': chainedBinaryExpr('AssignmentExpression', '|='),
  '^=': chainedBinaryExpr('AssignmentExpression', '^='),
  'seq': function(){
    var expressions, res$, i$, to$;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    expressions = res$;
    return {
      type: 'SequenceExpression',
      expressions: expressions.map(this.compile)
    };
  },
  'array': function(){
    var elements, res$, i$, to$;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    elements = res$;
    return {
      type: 'ArrayExpression',
      elements: elements.map(this.compile)
    };
  },
  'object': function(){
    var args, res$, i$, to$, env, compile, keysValues, keys, values;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    compile = (env = this).compile;
    if (args.length % 2 !== 0) {
      throw Error("Expected even number of arguments to object macro, but got " + args.length);
    }
    keysValues = (keys = [], values = [], args.forEach(function(a, i){
      return (i % 2 ? values : keys).push(a);
    }), zip(keys, values));
    return {
      type: 'ObjectExpression',
      properties: keysValues.map(function(arg$){
        var k, v;
        k = arg$[0], v = arg$[1];
        return {
          type: 'Property',
          kind: 'init',
          value: compile(v),
          key: compile(k)
        };
      })
    };
  },
  'var': function(name, value){
    if (arguments.length > 2) {
      throw Error("Expected variable declaration to get 1 or 2 arguments, but got " + arguments.length + ".");
    }
    return {
      type: 'VariableDeclaration',
      kind: "var",
      declarations: [{
        type: 'VariableDeclarator',
        id: this.compile(name),
        init: value ? this.compile(value) : null
      }]
    };
  },
  'let': function(name, value){
    if (arguments.length > 2) {
      throw Error("Expected variable declaration to get 1 or 2 arguments, but got " + arguments.length + ".");
    }
    return {
      type: 'VariableDeclaration',
      kind: "let",
      declarations: [{
        type: 'VariableDeclarator',
        id: this.compile(name),
        init: value ? this.compile(value) : null
      }]
    };
  },
  'const': function(name, value){
    if (arguments.length > 2) {
      throw Error("Expected variable declaration to get 1 or 2 arguments, but got " + arguments.length + ".");
    }
    return {
      type: 'VariableDeclaration',
      kind: "const",
      declarations: [{
        type: 'VariableDeclarator',
        id: this.compile(name),
        init: value ? this.compile(value) : null
      }]
    };
  },
  'block': function(){
    var statements, res$, i$, to$;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    statements = res$;
    return {
      type: 'BlockStatement',
      body: this.compileMany(statements).map(statementify)
    };
  },
  'switch': function(discriminant){
    var cases, res$, i$, to$, this$ = this;
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    cases = res$;
    return {
      type: 'SwitchStatement',
      discriminant: this.compile(discriminant),
      cases: cases.map(function(it){
        return it.values;
      }).map(function(arg$){
        var t, c;
        t = arg$[0], c = slice$.call(arg$, 1);
        return {
          type: 'SwitchCase',
          test: (t = this$.compile(t), t.type === 'Identifier' && t.name === 'default' ? null : t),
          consequent: this$.compileMany(c).map(statementify)
        };
      })
    };
  },
  'if': function(test, consequent, alternate){
    var that;
    return {
      type: 'IfStatement',
      test: this.compile(test),
      consequent: statementify(this.compile(consequent)),
      alternate: (that = alternate) ? statementify(this.compile(that)) : null
    };
  },
  '?:': function(test, consequent, alternate){
    return {
      type: 'ConditionalExpression',
      test: this.compile(test),
      consequent: this.compile(consequent),
      alternate: this.compile(alternate)
    };
  },
  'while': function(test){
    var body, res$, i$, to$;
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    body = res$;
    return {
      type: 'WhileStatement',
      test: this.compile(test),
      body: optionallyImplicitBlockStatement(this, body)
    };
  },
  'dowhile': function(test){
    var body, res$, i$, to$;
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    body = res$;
    return {
      type: 'DoWhileStatement',
      test: this.compile(test),
      body: optionallyImplicitBlockStatement(this, body)
    };
  },
  'for': function(init, test, update){
    var body, res$, i$, to$;
    res$ = [];
    for (i$ = 3, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    body = res$;
    return {
      type: 'ForStatement',
      init: compileUnlessEmptyList(this.compile, init),
      test: compileUnlessEmptyList(this.compile, test),
      update: compileUnlessEmptyList(this.compile, update),
      body: optionallyImplicitBlockStatement(this, body)
    };
  },
  'forin': function(left, right){
    var body, res$, i$, to$;
    res$ = [];
    for (i$ = 2, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    body = res$;
    return {
      type: 'ForInStatement',
      left: this.compile(left),
      right: this.compile(right),
      body: optionallyImplicitBlockStatement(this, body)
    };
  },
  'break': function(arg){
    return {
      type: 'BreakStatement',
      label: arg ? this.compile(arg) : null
    };
  },
  'continue': function(arg){
    return {
      type: 'ContinueStatement',
      label: arg ? this.compile(arg) : null
    };
  },
  'label': function(label, body){
    var ref$;
    if ((ref$ = arguments.length) !== 1 && ref$ !== 2) {
      throw Error("Expected `label` macro to get 1 or 2 arguments, but got " + arguments.length);
    }
    body = body
      ? statementify(this.compile(body))
      : {
        type: 'EmptyStatement'
      };
    return {
      type: 'LabeledStatement',
      label: this.compile(label),
      body: body
    };
  },
  'return': function(arg){
    var ref$;
    if ((ref$ = arguments.length) !== 0 && ref$ !== 1) {
      throw Error("Expected `return` macro to get 0 or 1 arguments, but got " + arguments.length);
    }
    return {
      type: 'ReturnStatement',
      argument: arg ? this.compile(arg) : null
    };
  },
  '.': (isComputedProperty = function(astNode){
    switch (astNode.type) {
    case 'Identifier':
      return false;
    default:
      return true;
    }
  }, dot = function(){
    var args, res$, i$, to$, env, compile, propertyCompiled, initial, last;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    compile = (env = this).compile;
    switch (false) {
    case args.length !== 1:
      return compile(args[0]);
    case args.length !== 2:
      propertyCompiled = compile(args[1]);
      return {
        type: 'MemberExpression',
        computed: isComputedProperty(propertyCompiled),
        object: compile(args[0]),
        property: propertyCompiled
      };
    case !(arguments.length > 2):
      initial = 0 < (i$ = args.length - 1) ? slice$.call(args, 0, i$) : (i$ = 0, []), last = args[i$];
      return dot.call(env, dot.apply(env, initial), dot.call(env, compile(last)));
    default:
      throw Error("dot called with no arguments");
    }
  }),
  'get': get = function(){
    var args, res$, i$, to$, env, compile, propertyCompiled, initial, last;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    compile = (env = this).compile;
    switch (false) {
    case args.length !== 1:
      return compile(args[0]);
    case args.length !== 2:
      propertyCompiled = compile(args[1]);
      return {
        type: 'MemberExpression',
        computed: true,
        object: compile(args[0]),
        property: propertyCompiled
      };
    case !(arguments.length > 2):
      initial = 0 < (i$ = args.length - 1) ? slice$.call(args, 0, i$) : (i$ = 0, []), last = args[i$];
      return get.call(env, get.apply(env, initial), get.call(env, compile(last)));
    default:
      throw Error("dot called with no arguments");
    }
  },
  'lambda': functionType('FunctionExpression'),
  'function': functionType('FunctionDeclaration'),
  'new': function(newTarget){
    var newArgs, res$, i$, to$;
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    newArgs = res$;
    if (newTarget == null) {
      throw Error("No target for `new`");
    }
    return {
      type: 'NewExpression',
      callee: this.compile(newTarget),
      arguments: newArgs.map(this.compile)
    };
  },
  'debugger': function(){
    if (arguments.length) {
      throw Error("Expected no arguments to `debugger` statement");
    }
    return {
      type: 'DebuggerStatement'
    };
  },
  'throw': function(item){
    if (arguments.length !== 1) {
      throw Error("Expected 1 argument to `throws`; got " + arguments.length);
    }
    return {
      type: 'ThrowStatement',
      argument: this.compile(item)
    };
  },
  'regex': function(expr, flags){
    var ref$;
    if ((ref$ = arguments.length) !== 1 && ref$ !== 2) {
      throw Error("Expected 1 or 2 arguments to `regex`; got " + arguments.length);
    }
    return {
      type: 'Literal',
      value: new RegExp(expr.value, flags != null ? flags.value : void 8)
    };
  },
  'try': (isPart = function(thing, clauseName){
    var first;
    if (!(thing.type === 'list')) {
      return false;
    }
    first = thing.values[0];
    return first.type === 'atom' && first.value === clauseName;
  }, function(){
    var args, res$, i$, to$, catchPart, finallyPart, others, catchClause, finallyClause;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    catchPart = null;
    finallyPart = null;
    others = [];
    args.forEach(function(it){
      if (isPart(it, 'catch')) {
        if (catchPart) {
          throw Error("Duplicate `catch` clause");
        }
        return catchPart = it.values.slice(1);
      } else if (isPart(it, 'finally')) {
        if (finallyPart) {
          throw Error("Duplicate `finally` clause");
        }
        return finallyPart = it.values.slice(1);
      } else {
        return others.push(it);
      }
    });
    catchClause = catchPart ? {
      type: 'CatchClause',
      param: this.compile(catchPart.shift()),
      body: optionallyImplicitBlockStatement(this, catchPart)
    } : null;
    finallyClause = finallyPart ? optionallyImplicitBlockStatement(this, finallyPart) : null;
    return {
      type: 'TryStatement',
      block: {
        type: 'BlockStatement',
        body: this.compileMany(others).map(statementify)
      },
      handler: catchClause,
      finalizer: finallyClause
    };
  }),
  'macro': function(){
    var env, compileAsMacro, that, form, esAst, result, k, v, name, targetName, aliasTargetMacro, userspaceMacro;
    env = this;
    compileAsMacro = function(esAst){
      var ref$, lookupFilename, displayedFilename, x$, newModule, requireSubstitute;
      ref$ = function(){
        var that, p;
        switch (false) {
        case !(that = env.filename):
          p = path.resolve(that);
          return [p, p];
        default:
          return [process.cwd(), null];
        }
      }(), lookupFilename = ref$[0], displayedFilename = ref$[1];
      x$ = newModule = new Module("eslisp-internal:" + displayedFilename, null);
      x$.paths = Module._nodeModulePaths(lookupFilename);
      x$.filename = displayedFilename;
      requireSubstitute = newModule.require.bind(newModule);
      return (function(require){
        return eval("(" + env.compileToJs(esAst) + ")");
      }.call(this, requireSubstitute));
    };
    switch (that = arguments.length) {
    case 1:
      form = arguments[0];
      switch (false) {
      case form.type !== 'atom':
        importCompilerspaceMacro(env, form.value, null);
        break;
      default:
        esAst = env.compile(form);
        result = compileAsMacro(esAst);
        switch (that = toString$.call(result).slice(8, -1)) {
        case 'Object':
          for (k in result) {
            v = result[k];
            importCompilerspaceMacro(env, k, v);
          }
          break;
        case 'Null':
          // fallthrough
        case 'Undefined':
          break;
        default:
          throw Error("Invalid macro source " + that + " (expected to get an Object, or a name argument and a Function)");
        }
      }
      break;
    case 2:
      name = arguments[0]; form = arguments[1];
      switch (false) {
      case form.type !== 'atom':
        name = name.value;
        targetName = form.value;
        aliasTargetMacro = env.findMacro(targetName);
        if (!aliasTargetMacro) {
          throw Error("Macro alias target `" + targetName + "` is not defined");
        }
        importCompilerspaceMacro(env, name, aliasTargetMacro);
        break;
      case form.type !== 'list':
        userspaceMacro = compileAsMacro(
        env.compile(
        form));
        name = name.value;
        importCompilerspaceMacro(env, name, userspaceMacro);
      }
      break;
    default:
      throw Error("Bad number of arguments to macro constructor (expected 1 or 2; got " + that + ")");
    }
    return null;
  },
  'quote': quote,
  'quasiquote': (qqBody = function(env, ast){
    var recurseOn, unquote, unquoteSplicing, ref$, head, rest;
    recurseOn = function(astList){
      return generateConcat(
      map(partialize$.apply(this, [qqBody, [env, void 8], [1]]))(
      astList.values));
    };
    unquote = function(it){
      if (arguments.length !== 1) {
        throw Error("Expected 1 argument to unquote but got " + rest.length);
      }
      return [env.compile(it)];
    };
    unquoteSplicing = function(it){
      if (arguments.length !== 1) {
        throw Error("Expected 1 argument to unquoteSplicing but got" + rest.length);
      }
      return {
        type: 'MemberExpression',
        computed: false,
        object: env.compile(it),
        property: {
          type: 'Identifier',
          name: 'values'
        }
      };
    };
    switch (false) {
    case ast.type !== 'list':
      ref$ = ast.values, head = ref$[0], rest = slice$.call(ref$, 1);
      switch (false) {
      case head != null:
        return [quote.call(env, {
          type: 'list',
          values: [],
          location: "returned from macro"
        })];
      case head.type !== 'atom':
        switch (head.value) {
        case 'unquote':
          return unquote.apply(null, rest);
        case 'unquote-splicing':
          return unquoteSplicing.apply(null, rest);
        default:
          return [recurseOn(ast)];
        }
        break;
      default:
        return [recurseOn(ast)];
      }
      break;
    default:
      return [quote.call(env, ast)];
    }
  }, generateConcat = function(concattableThings){
    return function(it){
      return {
        type: 'ObjectExpression',
        properties: [
          {
            type: 'Property',
            kind: 'init',
            key: {
              type: 'Identifier',
              name: 'type'
            },
            value: {
              type: 'Literal',
              value: 'list',
              raw: "\"list\""
            }
          }, {
            type: 'Property',
            kind: 'init',
            key: {
              type: 'Identifier',
              name: 'values'
            },
            value: {
              type: 'CallExpression',
              callee: {
                type: 'MemberExpression',
                object: {
                  type: 'MemberExpression',
                  object: {
                    type: 'Identifier',
                    name: 'Array'
                  },
                  property: {
                    type: 'Identifier',
                    name: 'prototype'
                  }
                },
                property: {
                  type: 'Identifier',
                  name: 'concat'
                }
              },
              arguments: it
            }
          }
        ]
      };
    }(
    map(function(it){
      if (toString$.call(it).slice(8, -1) === 'Array') {
        return {
          type: 'ArrayExpression',
          elements: it
        };
      } else {
        return it;
      }
    })(
    concattableThings));
  }, qq = function(arg){
    var env, firstArg, rest;
    env = this;
    if (arguments.length > 1) {
      throw Error("Too many arguments to quasiquote (`); expected 1, got " + arguments.length);
    }
    if (arg.type === 'list' && arg.values.length) {
      firstArg = arg.values[0];
      if (firstArg.type === 'atom' && firstArg.value === 'unquote') {
        rest = arg.values.slice(1)[0];
        return env.compile(rest);
      } else {
        return generateConcat(
        map(partialize$.apply(this, [qqBody, [env, void 8], [1]]))(
        arg.values));
      }
    } else {
      return quote.call(env, arg);
    }
  })
};
module.exports = {
  parent: null,
  contents: contents
};
function partialize$(f, args, where){
  var context = this;
  return function(){
    var params = slice$.call(arguments), i,
        len = params.length, wlen = where.length,
        ta = args ? args.concat() : [], tw = where ? where.concat() : [];
    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
    return len < wlen && len ?
      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);
  };
}